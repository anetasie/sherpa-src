#!/usr/bin/env python
# 
#  Copyright (C) 2010  Smithsonian Astrophysical Observatory
#
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License along
#  with this program; if not, write to the Free Software Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#


import sys
import numpy
import paramio
import sherpa.astro.ui as sherpa

__verbose=None


def set_verbose(verb):
    global __verbose
    __verbose=verb


def get_verbose():
    return __verbose


def _check_if_nan(arg, format="%.4e"):
    val = "INDEF"
    if arg is not None:
        if not (numpy.isnan(arg) or numpy.isinf(arg)):
            val = format % arg
    return val

def read_param_file(filename):

    # try:
    #     pfile = paramio.paramopen(filename, "rwL", sys.argv)
    # except:
    #     raise IOError("could not open parameter file '%s'" % filename)

    args = sys.argv[:]
    if len(args) > 1 and args[1].startswith("@@"):
        try:
            pfile = paramio.paramopen(None, "rw", args)
        except:
            raise IOError("could not open parameter file '%s'" % filename)
    else:
        try:
            pfile = paramio.paramopen(filename, "rwL", sys.argv)
        except:
            raise IOError("could not open parameter file '%s'" % filename)

    params = {}

    # ARF file
    params["arf"]  = paramio.pgetstr(pfile,"arf")

    # RMF file
    params["rmf"]  = paramio.pgetstr(pfile,"rmf")

    # Sherpa model definition string
    params["mdl"]  = paramio.pgetstr(pfile,"model")
    params["mdl"]  = params["mdl"].strip("\"' ")

    # ';' delimited string of parameter values
    params["vals"] = paramio.pgetstr(pfile,"paramvals")
    params["vals"]  = params["vals"].strip("\"' ")

    # upper and lower energy in keV
    params["emin"] = None
    if paramio.pgetstr(pfile,"emin").upper() != "INDEF":
        params["emin"] = paramio.pgetd(pfile,"emin")

    params["emax"] = None
    if paramio.pgetstr(pfile,"emax") != "INDEF":
        params["emax"] = paramio.pgetd(pfile,"emax")

    # observed instrumental upper and lower energy in keV
    params["oemin"] = params["emin"]
    if paramio.pgetstr(pfile,"oemin").upper() != "INDEF":
        params["oemin"] = paramio.pgetd(pfile,"oemin")

    params["oemax"] = params["emax"]
    if paramio.pgetstr(pfile,"oemax").upper() != "INDEF":
        params["oemax"] = paramio.pgetd(pfile,"oemax")

    # rate double, default=1.0
    # count rate in [counts s^-1]
    params["rate"]  = paramio.pgetd(pfile,"rate")

    # pflux double, default=None
    # photon flux in energy range [photon cm^-2 s^-1]
    params["pflux"] = None
    if paramio.pgetstr(pfile,"pflux").upper() != "INDEF":
        params["pflux"] = paramio.pgetd(pfile,"pflux")

    # flux double, default=None
    # energy flux in energy range [erg cm^-2 s^-1]
    params["flux"]  = None
    if paramio.pgetstr(pfile,"flux").upper() != "INDEF":
        params["flux"]  = paramio.pgetd(pfile,"flux")

    # opt string, default="rate", values=(rate|flux|pflux)
    # convert: rate->flux,pflux or flux->rate,pflux
    params["opt"]  = paramio.pgetstr(pfile,"opt")
    params["opt"]  = params["opt"].strip("\"' ")

    params["verbose"] = paramio.pgeti(pfile, "verbose")

    return params, pfile


def print_params(rate, pflux, flux, oemin, oemax, emin, emax):
    if get_verbose() > 2:
        print('Model fluxes:\n' +
              'Rate (%.2g,%.2g)= %s count s^-1\n' %
              (oemin, oemax, _check_if_nan(rate, "%.5g")) +
              'Photon Flux (%.2g,%.2g)= %s photon cm^-2 s^-1\n' %
              (emin, emax, _check_if_nan(pflux, "%.5g")) + 
              'Energy Flux (%.2g,%.2g)= %s erg cm^-2 s^-1' %
              (emin, emax, _check_if_nan(flux, "%.5g")))


def write_params(pfile, rate, pflux, flux):

    paramio.pputstr(pfile, "rate",  _check_if_nan(rate))
    paramio.pputstr(pfile, "pflux", _check_if_nan(pflux))
    paramio.pputstr(pfile, "flux",  _check_if_nan(flux))

    paramio.paramclose(pfile)



def main():

    params={}
    params, file = read_param_file("modelflux.par")

    set_verbose(params["verbose"])

    if params["rmf"] == "" or params["rmf"].upper() == "INDEF":
        raise IOError("an RMF file is required")

    rmf = sherpa.unpack_rmf(params["rmf"])

    counts = numpy.zeros(rmf.detchans)
    channel = numpy.arange(1, rmf.detchans+1)
    data = sherpa.DataPHA('', channel, counts)
    sherpa.set_data(data)
    sherpa.set_rmf(rmf)

    if not (params["arf"] == "" or params["arf"].upper() == "INDEF"):
        arf = sherpa.unpack_arf(params["arf"])

        # By not setting an exposure time for DataPHA, the convolved model returns
        # the predicted count rate, not predicted counts.
        arf.exposure = None
        sherpa.set_arf(arf)


    sherpa.set_analysis("energy")
    sherpa.set_source(params["mdl"])
    exec params["vals"]

    calc_cnt_rate = sherpa.calc_model_sum(lo=params["oemin"], # counts sec^-1
                                          hi=params["oemax"])
    calc_eflux = sherpa.calc_energy_flux(lo=params["emin"], # ergs cm^-2 sec^-1
                                         hi=params["emax"])
    calc_pflux = sherpa.calc_photon_flux(lo=params["emin"], # photons cm^-2 sec^-1
                                         hi=params["emax"])

    opt = params["opt"].lower().strip()
    if opt == "flux":
        obs_flux = params["flux"]
        if obs_flux is None:
            raise IOError("please provide a flux, using 'flux' parameter")
        params["rate"] = (calc_cnt_rate/calc_eflux) * obs_flux
        params["pflux"] = (calc_pflux/calc_cnt_rate) * params["rate"]

    elif opt == "pflux":
        obs_flux = params["pflux"]
        if obs_flux is None:
            raise IOError("please provide a photon flux, using 'pflux' parameter")
        params["rate"] = (calc_cnt_rate/calc_pflux) * obs_flux
        params["flux"] = (calc_eflux/calc_cnt_rate) * params["rate"]

    elif opt == "rate":
        obs_rate = params["rate"]
        params["flux"] = (calc_eflux/calc_cnt_rate) * obs_rate
        params["pflux"] = (calc_pflux/calc_cnt_rate) * obs_rate

    else:
        raise IOError("unknown option '%s'" % opt)

    print_params(params["rate"], params["pflux"], params["flux"],
                 params["oemin"], params["oemax"], params["emin"],
                 params["emax"])

    write_params(file, params["rate"], params["pflux"], params["flux"])


if __name__ == "__main__":

    import sys

    try:
    
        main()
    
    except Exception,e:
        sys.stderr.write("modelflux: ERROR: %s\n" % str(e))
        sys.exit(1)
